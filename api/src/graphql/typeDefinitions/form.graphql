  input KeyValueObject{
    key   : String!
    value : FormValue!
  }


  type FieldKeyValuePair{
    """
    KeyValueObject holds submitted infomation from the forms
    within the frontend.
    The reason it shaped as a key value pair is due to the fact 
    form state is set as a object in which we can just easily populate
    the object by having a key which is just the name of the field and of that
    value of that field
    """
    key   : String!
    value : FormValue!
  }

  type Submitter{
    """
    
    """
    uuid                               : String!
    form                               : String!
    formPrimaryIdentifierKeys          : Parser
    fields                             : [FieldKeyValuePair!]! @relationship(type : "HAS_FIELD_VALUE", direction : OUT)
    formReferenceKeys                  : [Submitter!]! @relationship(type : "REFERENCE_PRIMARY_KEY", direction : OUT)
    connectedFormsReferencingSubmitter : [Submitter!]! @relationship(type : "REFERENCE_PRIMARY_KEY", direction : IN)
     
  }

  type FormDraft {
    """
      FormDraft allows the user to save a draft of any form they are currently
      editing so they do not lose the data they have already input
    """
    draft_id: ID! @id
    form_id: String!
    patient_id: String!
    data: String
  }

  type Form {
    """
    
    """
    form_id                       : String
    form_name                     : String
    form_relationship_cardinality : FormValue
    has_next_question             : Field @relationship(type : "HAS_NEXT_QUESTION", direction : OUT)
    next_form                     : [Form!]!  @relationship(type : "NEXT_FORM", direction : OUT)
    primary_key                   : [Field!]! @relationship(type : "HAS_PRIMARY_KEY", direction : OUT)
    foreign_key                   : [Field!]! @relationship(type : "HAS_FOREIGN_KEY", properties : "reference", direction : OUT)
    identifier                    : [Field!]! @cypher(statement: """ MATCH (f:Form)-[:HAS_PRIMARY_KEY]->(pk)
                                                         WHERE NOT ()-[:NEXT_FORM]->(f)
                                                         RETURN pk 
                                                     """ )
  }

  type Field {
    """
    Field metadata holds all the informaton needed to populate
    the frontend dynamically
    """
    label             : String
    description       : String
    name              : String
    type              : String
    regex             : String
    value             : FormValue
    set               : SampleSet
    required          : Boolean
    component         : String
    conditionals      : Parser
    placeholder       : String
    filter            : Parser
    has_next_question : Field @relationship(type : "HAS_NEXT_QUESTION", direction : OUT)
    foreign_key_to    : [Form!]! @relationship(type : "HAS_FOREIGN_KEY",  direction : IN)
    primaryFormIdentifiers    : Form @relationship(type : "HAS_PRIMARY_KEY", direction : IN)
  }

  interface reference @relationshipProperties {
    """
    reference relation holds extra information to inter connection
    Override: switches any metadata value within the field its connected to 
    [EX: a reference key might not be required witin the current form but is set to required]
    
    relationship_cardinality : holds the how many time the referencekey can be allocated to another submitter
    EX : Radiation has a relationship cardinality of 1 towards Treatment meaning that per each Treatment generated
    we can only refernce the primary identifiers once
    """
    relationship_cardinality : FormValue
    override                 : Parser
  }


  type Query {

    PopulateForm(id : String!) : [Field]
    @cypher( statement: """ 
    MATCH (:Form {form_id : $id})-[:HAS_NEXT_QUESTION*]->(f:Field) RETURN f
    """)

  }
