  input KeyValueObject{
    key   : String!
    value : FormValue!
  }


  type FieldKeyValuePair{
    """
    KeyValueObject holds submitted infomation from the forms
    within the frontend.
    The reason it shaped as a key value pair is due to the fact 
    form state is set as a object in which we can just easily populate
    the object by having a key which is just the name of the field and of that
    value of that field
    """
    key   : String!
    value : FormValue!
  }

  type Patient {
    patient_id: String!
    program_id: String!
    study: String
    submissions: [Submission] @relationship(type: "DATA_FOR", direction: IN)
  }

  type Submission { # This type will replace the Submitter type described below
    submission_id: ID! @id
    form_id: String!
    patient: Patient! @relationship(type: "DATA_FOR", direction: OUT)
    fields: [FieldKeyValuePair!]! @relationship(type: "HAS_VALUE", direction: OUT)
    submittedBy: KeycloakUser! @relationship(type: "SUBMITTED_BY", direction: OUT)
  }

  type Submitter{
    """
    
    """
    uuid                               : String!
    form                               : String!
    formPrimaryIdentifierKeys          : Parser
    fields                             : [FieldKeyValuePair!]! @relationship(type : "HAS_FIELD_VALUE", direction : OUT)
    formReferenceKeys                  : [Submitter!]! @relationship(type : "REFERENCE_PRIMARY_KEY", direction : OUT)
    connectedFormsReferencingSubmitter : [Submitter!]! @relationship(type : "REFERENCE_PRIMARY_KEY", direction : IN)
    submittedByKeycloakUser            : KeycloakUser! @relationship(type : "SUBMITTED_BY", direction : OUT)
  }

  type FormDraft {
    """
      FormDraft allows the user to save a draft of any form they are currently
      editing so they do not lose the data they have already input
    """
    draft_id: ID! @id
    form_id: String!
    patient_id: String!
    secondary_ids: String # Secondary IDs are fields that are unique to a form, but are not part of the patient's data
    data: String
    createdBy: KeycloakUser @relationship(type: "CREATED_BY", direction: OUT) 
  }

  type Form {
    """
    
    """
    form_id                       : String
    form_name                     : String
    form_relationship_cardinality : FormValue
    next_form                     : [Form!]!  @relationship(type : "NEXT_FORM", direction : OUT)
    fields: [Field!] @relationship(type: "BELONGS_TO", direction: IN, properties: "IsID")
    has_next_question: [Field] @relationship(type : "HAS_NEXT_QUESTION", direction : OUT)
  }

  type Field {
    """
    Field metadata holds all the informaton needed to populate
    the frontend dynamically
    """
    label             : String
    description       : String
    name              : String
    type              : String
    regex             : String
    value             : FormValue
    set               : SampleSet
    required          : Boolean
    component         : String
    conditionals      : Parser
    placeholder       : String
    filter            : Parser
    has_next_question: Field @relationship(type : "HAS_NEXT_QUESTION", direction : OUT)
    belongs_to(isID: Boolean): Form! @relationship(type: "BELONGS_TO", direction: OUT)
  }

  interface reference @relationshipProperties {
    """
    reference relation holds extra information to inter connection
    Override: switches any metadata value within the field its connected to 
    [EX: a reference key might not be required witin the current form but is set to required]
    
    relationship_cardinality : holds the how many time the referencekey can be allocated to another submitter
    EX : Radiation has a relationship cardinality of 1 towards Treatment meaning that per each Treatment generated
    we can only refernce the primary identifiers once
    """
    relationship_cardinality : FormValue
    override                 : Parser
  }

  interface IsID @relationshipProperties {
    isID: Boolean!
    override: Parser
  }


  type Query {

    GetFormFields(id : String!) : [Field]
    @cypher( statement: """ 
    MATCH (:Form {form_id : $id})-[:HAS_NEXT_QUESTION*]->(f:Field) RETURN f
    """)
    GetRootForm: Form @cypher(statement: """
    MATCH (f:Form)
    WHERE NOT ()-[:NEXT_FORM]->(f)
    RETURN f
    """)
    GetPatientID: [Field!]! @cypher(statement:"""
    MATCH (f:Form)
    WHERE NOT ()-[:NEXT_FORM]->(f)
    WITH f
    MATCH (n:Field)-[r:BELONGS_TO]->(f)
    WHERE r.isID = true
    RETURN n
    """)
  }

  type Mutation {
    findOrCreatePatient(patientID: String!, programID: String!, study: String): Patient
  }
